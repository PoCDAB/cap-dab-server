#
#    CFNS - Rijkswaterstaat CIV, Delft Â© 2021 - 2022 <cfns@rws.nl>
#
#    Copyright 2021 - 2022 Bastiaan Teeuwen <bastiaan@mkcl.nl>
#
#    This file is part of cap-dab-server
#
#    cap-dab-server is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    cap-dab-server is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with cap-dab-server. If not, see <https://www.gnu.org/licenses/>.
#

import copy                                                         # For saving/restoring Config objects
import os                                                           # For file I/O
import logging                                                      # Logging facilities
from dab.boost_info_parser import BoostInfoTree, BoostInfoParser    # C++ Boost INFO format parser (used for dabmux.cfg)

logger = logging.getLogger('server.dab')

# ODR-DabMux config file wrapper class
class ODRMuxConfig():
    def __init__(self, zmqfifo, streams):
        self.p = BoostInfoParser()
        self.zmqfifo = zmqfifo
        self.streams = streams

        self.oldcfg = None

    def load(self, cfgfile):
        if cfgfile is None:
            return False

        self.file = cfgfile

        def overwrite():
            # overwrite/set zmqendpoint to the temp file generated by DABServer
            self.cfg.remotecontrol['zmqendpoint'] = f'ipc://{self.zmqfifo}'

            self.cfg['subchannels']
            del self.cfg['subchannels']
            self.cfg['components']

            # Generate subchannels from streams.ini
            i = 0
            for s, t, c, o in self.streams.streams:
                self.cfg.subchannels[s]['id'] = str(i)

                output_type = c['output_type']
                if output_type == 'dabplus':
                    self.cfg.subchannels[s]['type'] = 'dabplus'
                elif output_type == 'dab':
                    self.cfg.subchannels[s]['type'] = 'audio'
                elif output_type == 'data':
                    self.cfg.subchannels[s]['type'] = 'packet'
                else:
                    logger.error(f'Invalid output_type: {output_type}')

                self.cfg.subchannels[s]['bitrate'] = c['bitrate']
                self.cfg.subchannels[s]['protection-profile'] = c['protection_profile']
                self.cfg.subchannels[s]['protection'] = c['protection']

                # Set our temporary output FIFO for IPC between odr-audioenc and odr-dabmux
                input_type = c['input_type']
                if input_type == 'gst':
                    self.cfg.subchannels[s]['inputproto'] = 'zmq'
                    self.cfg.subchannels[s]['inputuri'] = f'ipc://{o}'
                    self.cfg.subchannels[s]['zmq-buffer'] = '40'
                    self.cfg.subchannels[s]['zmq-prebuffering'] = '20'
                elif input_type == 'file':
                    self.cfg.subchannels[s]['inputproto'] = 'file'
                    self.cfg.subchannels[s]['inputuri'] = c['input']
                elif input_type == 'fifo':
                    self.cfg.subchannels[s]['inputproto'] = 'file'
                    self.cfg.subchannels[s]['inputuri'] = c['input']
                    self.cfg.subchannels[s]['nonblock'] = 'true'

                i += 1

            # Generate components
            for name, component in self.cfg.components:
                stream_cfg = self.streams.getcfg(str(component['subchannel']))

                if stream_cfg is None:
                    continue

                output_type = stream_cfg['output_type']
                if output_type == 'dabplus':
                    component['type'] = '2'     # multi-channel audio stream
                elif output_type == 'dab':
                    component['type'] = '2'     # multi-channel audio stream
                elif output_type == 'data':
                    component['type'] = '59'    # IP data stream
                else:
                    logger.error(f'Invalid output_type: {output_type}')

                #self.cfg.components[comp_name]['service'] = 'srv-audio' # FIXME FIXME FIXME configure this in the GUI!!!
                #self.cfg.components[comp_name]['subchannel'] = s
                if stream_cfg.getboolean('mot_enable') == True:
                    component['user-applications']['userapp'] = 'slideshow'

            return True

        # attempt to read the file
        if cfgfile is not None and os.path.isfile(cfgfile):
            self.p.read(cfgfile)
            self.cfg = self.p.getRoot()

            if not overwrite():
                return False

            self.write()

            return True

        logger.warning(f'Unable to read {cfgfile}, creating a new config file')

        # generate a new config file otherwise
        self.cfg = BoostInfoTree()

        # load in defaults, refer to:
        # - https://github.com/Opendigitalradio/ODR-DabMux/blob/master/doc/example.mux
        # - https://github.com/Opendigitalradio/ODR-DabMux/blob/master/doc/advanced.mux

        self.cfg.general['dabmode'] = '1'               # DAB Transmission mode (https://en.wikipedia.org/wiki/Digital_Audio_Broadcasting#Bands_and_modes)
        self.cfg.general['nbframes'] = '0'              # Don't limit the number of ETI frames generated
        self.cfg.general['syslog'] = 'false'
        self.cfg.general['tist'] = 'false'              # Disable downloading leap second information
        self.cfg.general['managementport'] = '0'        # Disable management port

        self.cfg.ensemble['id'] = '0x8FFF'               # Default to The Netherlands
        self.cfg.ensemble['ecc'] = '0xE3'
        self.cfg.ensemble['local-time-offset'] = 'auto'
        self.cfg.ensemble['international-table'] = '1'
        self.cfg.ensemble['reconfig-counter'] = 'hash'   # Enable FIG 0/7
        self.cfg.ensemble['label'] = 'DAB Ensemble'      # Set a generic default name
        self.cfg.ensemble['shortlabel'] = 'DAB'

        #root.services
        # Create a default Pseudo alarm announcement subchannel
        #  This sub-channel is an integral part of the PoC and aims to support warning messages on devices that don't
        #  support DAB-EWF or even the DAB Alarm Announcement.
        #self.cfg.ensemble.announcements.alarm['cluster'] = '1'
        #self.cfg.ensemble.announcements.alarm.flags['Alarm'] = 'true'
        #self.cfg.ensemble.announcements.alarm['subchannel'] = 'sub-alarm'

        #self.cfg.services['srv-alarm']['id'] = '0x8AAA'
        #self.cfg.services['srv-alarm']['label'] = 'NL-Alert'
        #self.cfg.services['srv-alarm']['shortlabel'] = 'NL-Alert'
        #self.cfg.services['srv-alarm']['pty'] = '3'
        #self.cfg.services['srv-alarm']['pty-sd'] = 'static'
        #self.cfg.services['srv-alarm']['announcements']['Alarm'] = 'true'
        #self.cfg.services['srv-alarm']['announcements']['clusters'] = '1'

        if not overwrite():
            return False

        # Output to stdout because we'll be piping the output into ODR-DabMux
        self.cfg.outputs['stdout'] = 'fifo:///dev/stdout?type=raw'

        self.write()

        return True

    def save(self):
        self.oldcfg = copy.deepcopy(self.cfg)

    def restore(self):
        if self.oldcfg is None:
            return

        self.cfg = self.oldcfg
        self.oldcfg = None

    def write(self):
        self.p.load(self.cfg)
        self.p.write(self.file)
